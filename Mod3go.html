<!DOCTYPE html>
<html>
<head>
  <title>Módulo 3</title>
  <style>
    body {
      background-color: #1E1E1E; 
      color: #D4D4D4;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }

    ul {
      list-style-type: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #3C9CDD; 
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
      z-index: 1000; 
    }

    li {
      float: left;
    }

    li a, .dropbtn {
      display: inline-block;
      color: #FFD43B; 
      text-align: center;
      padding: 14px 20px;
      text-decoration: none;
      font-weight: bold;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    li a:hover, .dropdown:hover .dropbtn {
      background-color: #2B7B9D;
      color: #FFFFFF;
      border-radius: 4px;
    }

    li.dropdown {
      display: inline-block;
    }

    .dropdown:hover .dropdown-content {
      display: block;
    }

    li:last-child {
      border-right: none;
    }

    h1 {
      color: #FFD43B;
      text-shadow: 3px 3px #2B7B9D;
      font-size: 36px;
      margin-top: 10px;
      margin-bottom: 20px;
    }

    p {
      font-size: 20px;
      margin: 20px 0;
      text-align: justify;
    }

    a {
      color: #FFD43B;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    center {
      margin-top: 20px;
    }

    .container {
      max-width: 800px;
      margin: auto;
      padding: 20px;
      text-align: center;
    }

    .content {
      padding-top: 70px;
    }

    pre {
      text-align: left;
      background-color: #2D2D2D;
      color: #D4D4D4;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 18px;
    }

    code {
      white-space: pre;
    }
  </style>
</head>
<body>

<ul>
  <li><a class="active" href="indexgo.html">Menu</a></li>
  <li class="dropdown">
    <a href="Mod1go.html">Módulo 1</a>
  </li>
  <li>
    <a href="Mod2go.html" class="dropbtn">Módulo 2</a>
  </li>
  <li class="dropdown">
    <a href="Mod3go.html" class="dropbtn">Módulo 3</a>
  </li>
  <li style="float:right"><a href="Sobrego.html">Sobre</a></li>
</ul>

<div class="content">
  <div class="container">
    <h1>Ordenações em vetores</h1>
    <h2>Permutação</h2>
    <pre><code>
      package main
      import ( "fmt") 
      var n int
      fmt.Print("Entre com a dimensão do vetor: ")
      fmt.Scan(&n)
      vetor := make([]int, n)
      for i := 0; i < n; i++ {
        fmt.Printf("Entre com a posição %d do vetor: ", i)
        fmt.Scan(&vetor[i])
      }
      fmt.Println("Vetor não ordenado:")
      for _, v := range vetor {
        fmt.Printf("[%d] ", v)
      }
      for i := 0; i < n; i++ {
        for j := n - 1; j > i; j-- {
          if vetor[i] > vetor[j] {
            vetor[i], vetor[j] = vetor[j], vetor[i]
          }
        }
      }
      fmt.Println("\nVetor ordenado:")
      for _, v := range vetor {
        fmt.Printf("[%d] ", v)
      }</code></pre>
    <p>Esse programa faz a ordenação por Permutação e funciona assim:</p>
    <p>Primeiro você cria o seu vetor e imprime ele. Depois você faz um for do i variando as posições normais do vetor e um for de j que varia da útlima posição do vetor até a atual. Dentro desse for você faz um if comparando se o elemento da posição i é maior ou menor que o da posição j, se você utilizar o maior vai ser crescente a ordenação, o menor decrescente. Depois faz um aux que vai ter o valor de da posição i, faz a posição i pegar o valor da posição j e faz a posição j pegar o valor de aux. Esse loop do for faz a ordenação então é só imprimir e pronto</p>
    <h2>Inserção Binária</h2>
    <pre><code>	
      package main
      import ("fmt")
      func main() {
        var n int
        fmt.Print("Entre com a dimensão do vetor: ")
        fmt.Scan(&n)
        if n <= 0 {
          fmt.Println("A dimensão do vetor deve ser maior que zero.")
          return
        }
        vetor := make([]int, n)
        for i := 0; i < n; i++ {
          fmt.Printf("Entre com o valor para a posição %d: ", i)
          fmt.Scan(&vetor[i])
        }
        fmt.Println("\nVetor não ordenado:")
        for _, v := range vetor {
          fmt.Printf("[%d] ", v)
        }
        for i := 1; i < n; i++ {
          temp := vetor[i]
          l, r := 0, i
          for l < r {
            pos := (l + r) / 2
            if vetor[pos] <= temp {
              l = pos + 1
            } else {
              r = pos
            }
          }
          for j := i; j > r; j-- {
            vetor[j] = vetor[j-1]
          }
          vetor[r] = temp
        }
        fmt.Println("\nVetor ordenado:")
        for _, v := range vetor {
          fmt.Printf("[%d] ", v)
        }
        fmt.Println()
      }
      </code></pre>
    <p>Esse código faz a ordenação por inserção Binária e funciona assim</p>
    <p>Você cria o vetor primeiro. Depois com um for de i que vai de 1 até n você ordena o vetor por meio da realização da média de dois limites sendo um inferior igual a 0 e um superior igual a i. Com ele criamos um while que fica em loop enquanto o inferior for menor que o superior. Dentro dele fazemos a média e se o valor da posição que deu na média for menor ou igual a uma variavel que pega o valor da posição i o limite inferior vai subir pra um acima da posição da média, se não o limite superior fica igual a posição da média. Fechando o while temos um for de j que vai de i até o limite superior decrescendo e dentro dele atribuimos o valor da posição j-1 a posição j para limpar espaço pra posição do limite superior. Por fim atribuimos a posição do limite superior o valor da posição i. Com esses loops o vetor é ordenado</p>
    <h2>Inserção Direta</h2>
    <pre><code>
      package main
import ("fmt")
func main() {
	var n int
	fmt.Print("Entre com a dimensão do vetor: ")
	fmt.Scan(&n)
	if n <= 0 {
		fmt.Println("A dimensão do vetor deve ser maior que zero.")
		return
	}
	vetor := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Printf("Entre com o valor para a posição %d: ", i)
		fmt.Scan(&vetor[i])
	}
	fmt.Println("\nVetor não ordenado:")
	for _, v := range vetor {
		fmt.Printf("[%d] ", v)
	}
	for i := 1; i < n; i++ {
		x := vetor[i]
		j := i
		for j > 0 && x < vetor[j-1] {
			vetor[j] = vetor[j-1]
			j--
		}
		vetor[j] = x
	}
	fmt.Println("\nVetor ordenado:")
	for _, v := range vetor {
		fmt.Printf("[%d] ", v)
	}
	fmt.Println()
}
</code></pre>
    <p>Esse código faz a ordenação por inserção direta e funciona assim:</p>
    <p>Após a criação do vetor vai ser um for que vai do 1 até o tamanho do vetor vai declarar x = valor da posição do vetor e j =posição do vetor,ainda dentro do for vai ter um while que vai comparar x com os valores do vetor anterior e deslocar para esquerda e vai continuar até que x seja encontrado,quando o while terminar,x é colocado na posição correta.É mostrado o vetor ordenado.</p>
    <h2>Seleção direta</h2>
    <pre><code>
      package main
import "fmt"
func main() {
	var n int
	fmt.Print("Entre com a dimensão do vetor: ")
	fmt.Scan(&n)
	vetor := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Printf("Entre com a posição %d do vetor: ", i)
		fmt.Scan(&vetor[i])
	}
	fmt.Println("Vetor não ordenado:")
	for _, v := range vetor {
		fmt.Printf("[%d] ", v)
	}
	for i := 0; i < n; i++ {
		k := i
		for j := i + 1; j < n; j++ {
			if vetor[j] < vetor[k] {
				k = j
			}
		}
		vetor[k], vetor[i] = vetor[i], vetor[k]
	}
	fmt.Println("\nVetor ordenado:")
	for _, v := range vetor {
		fmt.Printf("[%d] ", v)
	}
}
</code></pre>
    <p>Esse código faz a ordenação por seleção direta e funciona assim:</p>
    <p>Após a criação do vetor vai ser um for que vai do 1 até o tamanho do vetor vai declarar x = valor da posição do vetor e j =posição do vetor,ainda dentro do for vai ter um while que vai comparar x com os valores do vetor anterior e deslocar para esquerda e vai continuar até que x seja encontrado,quando o while terminar,x é colocado na posição correta.É mostrado o vetor ordenado.</p>
      <h2>Bolha</h2>
      <pre><code>
        package main

import "fmt"

func main() {
	var n int
	fmt.Print("Entre com a dimensão do vetor: ")
	fmt.Scan(&n)
	vet := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Printf("Entre com a posição %d do vetor: ", i)
		fmt.Scan(&vet[i])
	}
	fmt.Println("Vetor não ordenado:")
	for _, v := range vet {
		fmt.Printf("[%d] ", v)
	}
	ind2 := n
	troquei := true
	for troquei {
		troquei = false
		for i := 0; i < ind2-1; i++ {
			if vet[i] > vet[i+1] {
				vet[i], vet[i+1] = vet[i+1], vet[i]
				troquei = true
			}
		}
		ind2--
	}
	fmt.Println("\nVetor ordenado por bolha:")
	for _, v := range vet {
		fmt.Printf("[%d] ", v)
	}
}
</code></pre>
      <p>Esse código faz a ordenação por bolha e funciona assim:</p>
    <p>Após a criação do vetor,um for vai verificar se o elemento atual é maior que o proximo,caso seja,ele trocará de posição(o maior ficara para frente) apos isso,diminuira o alcance pois uma parte ja estaria ordenada.A.Esse processo de ordenação de pares vai se repetir por todo o vetor,o que também acaba tornando o metodo de bolha o mais demorado dentre todos.</p>
    <h1>Buscas no vetor</h1>
    <h2>Simples</h2>
    <pre><code>
      package main
      import "fmt"
      func main() {
        var n, e int
        fmt.Print("Entre com a dimensão do vetor: ")
        fmt.Scan(&n)
        if n <= 0 {
          fmt.Println("A dimensão do vetor deve ser maior que 0.")
          return
        }
        vetor := make([]int, n)
          for i := 0; i < n; i++ {
          fmt.Printf("Entre com a posição %d do vetor: ", i)
          fmt.Scan(&vetor[i])
        }
        fmt.Println("Vetor:")
        for _, v := range vetor {
          fmt.Printf("[%d] ", v)
        }
        fmt.Println() 
        fmt.Print("Entre com o número a ser buscado: ")
        fmt.Scan(&e)
        ok := 0
        for i := 0; i < n; i++ {
          if vetor[i] == e {
            ok++
            fmt.Printf("O número %d foi encontrado na posição %d do vetor\n", e, i)
          }
        }
        if ok > 0 {
          fmt.Printf("O número %d foi encontrado %d vez(es)\n", e, ok)
        } else {
          fmt.Println("O número não foi encontrado no vetor.")
        }
      }
      </code></pre>
    <p>Esse código faz a busca de um elemento em um vetor e funciona assim:</p>
    <p>Após a criação do vetor, vai ser pedido o numero desejado.Apos isso,um for vai verificar se no vetor existe esse numero,caso exista,  em um print uma variavel vai falar quantas vezes ele apareceu no codigo e outra em quais posições ele apareceu no vetor.</p>
    <h2>Binária</h2>
    <pre><code>
      package main

      import "fmt"
      
      func main() {
        var n int
        fmt.Print("Entre com um numero = ")
        fmt.Scan(&n)
        vet := make([]int, 0, n)
        for i := 0; i < n; i++ {
          ok := false
          var valor int
          for !ok {
            fmt.Printf("Entre com a posição %d = ", i)
            fmt.Scan(&valor)
            ok = true
            for _, v := range vet {
              if v == valor {
                fmt.Println("Não é permitido ter posições com valores iguais")
                ok = false
                break
              }
            }
            if ok {
              vet = append(vet, valor)
            }
          }
        }
        fmt.Println("Vetor:")
        for _, v := range vet {
          fmt.Printf("[%d] ", v)
        }
        for i := 0; i < n; i++ {
          for j := n - 1; j > i; j-- {
            if vet[j] < vet[j-1] {
              vet[j], vet[j-1] = vet[j-1], vet[j]
            }
          }
        }
        fmt.Println("\nVetor ordenado:")
        for _, v := range vet {
          fmt.Printf("[%d] ", v)
        }
        var ele int
        fmt.Print("\nEntre com um numero = ")
        fmt.Scan(&ele)
        l, r := 0, n-1
        encontrado := false
        for l <= r {
          pos := (l + r) / 2
          if vet[pos] == ele {
            fmt.Printf("O elemento %d foi encontrado na posição %d do vetor\n", ele, pos)
            encontrado = true
            break
          } else if vet[pos] < ele {
            l = pos + 1
          } else {
            r = pos - 1
          }
        }
        if !encontrado {
          fmt.Printf("O elemento %d não foi encontrado\n", ele)
        }
      }
      </code></pre>
    <p>Esse código faz a busca binária em um vetor e funciona assim: </p>
    <p>Após a criação do vetor, um while verifica se ele tem numeros repetidos e o impede de coloca-los.Apos isso o vetor é ordenado por Permutação.Um while verifica se o numero procurado existe,ele verifica se o numero é maior ou menor que a posição central do vetor,caso seja maior, ele irá "excluir" os numeros anteriores e ira focar apenas nos numeros posteriores e vice-versa.Esse processo se repete até o numero ser achado.</p>
    <h1>Ordenações na matriz</h1>
      <h2>Inteira</h2>
    <pre><code>	
      package main

      import "fmt"
      
      func main() {
        var linhas, colunas int
        fmt.Print("Digite o número de linhas: ")
        fmt.Scan(&linhas)
        fmt.Print("Digite o número de colunas: ")
        fmt.Scan(&colunas)
        matriz := make([][]int, linhas)
        for i := range matriz {
          matriz[i] = make([]int, colunas)
        }
        for i := 0; i < linhas; i++ {
          for j := 0; j < colunas; j++ {
            fmt.Printf("Digite o valor para a posição [%d][%d]: ", i, j)
            fmt.Scan(&matriz[i][j])
          }
        }
        total := linhas * colunas
        valores := make([]int, total)
        index := 0
        for i := 0; i < linhas; i++ {
          for j := 0; j < colunas; j++ {
            valores[index] = matriz[i][j]
            index++
          }
        }
        for i := 0; i < total; i++ {
          for j := total - 1; j > i; j-- {
            if valores[j-1] > valores[j] {
              valores[j-1], valores[j] = valores[j], valores[j-1]
            }
          }
        }
        index = 0
        for i := 0; i < linhas; i++ {
          for j := 0; j < colunas; j++ {
            matriz[i][j] = valores[index]
            index++
          }
        }
        fmt.Println("\nMatriz completamente ordenada:")
        for i := 0; i < linhas; i++ {
          for j := 0; j < colunas; j++ {
            fmt.Printf("[%d] ", matriz[i][j])
          }
          fmt.Println()
        }
      }
      </pre>
    <p>Esse código ordena a matriz inteira e funciona assim:</p>
    <p>Após a criação da matriz,um vetor é criado com o mesmo tamanho da matriz,obtendo todos os valores dela.Após isso,um for executa a ordenação por permutação no vetor, e após o vetor ter sido ordenado,outro laço faz com que por meio das colunas e das linhas,o valor da matriz fique ordenado a partir do vetor.</p>
    <h1>Busca na matriz</h1>
    <pre><code>	
      package main

import "fmt"

func main() {
	var linhas, colunas, valor int
	fmt.Print("Digite o número de linhas: ")
	fmt.Scan(&linhas)
	fmt.Print("Digite o número de colunas: ")
	fmt.Scan(&colunas)
	matriz := make([][]int, linhas)
	for i := range matriz {
		matriz[i] = make([]int, colunas)
	}
	for i := 0; i < linhas; i++ {
		for j := 0; j < colunas; j++ {
			fmt.Printf("Digite o valor para a posição [%d][%d]: ", i, j)
			fmt.Scan(&matriz[i][j])
		}
	}
	fmt.Print("\nDigite o valor a ser buscado: ")
	fmt.Scan(&valor)
	encontrado := false
	for i := 0; i < linhas; i++ {
		for j := 0; j < colunas; j++ {
			if matriz[i][j] == valor {
				fmt.Printf("Valor %d encontrado na posição [%d][%d]\n", valor, i, j)
				encontrado = true
			}
		}
	}
	if !encontrado {
		fmt.Printf("Valor %d não encontrado na matriz\n", valor)
	}
}
</code></pre>
    <p>Esse código faz a busca de um elemento numa matriz e funciona assim:</p>
    <p>Após a criação da matriz,o usuario coloca o numero desejado,e um laço feio de dois fors faz com que procure o numero em toda a matriz.</p>
  <h1>Video</h1>
          <video width="500" controls>
      <source src="WhatsApp Video 2024-11-12 at 22.12.13.mp4" type="video/mp4">
    </video>
  </div>
</div>

</body>
</html>
